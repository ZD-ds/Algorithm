<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
<script>
    //二叉树的概念和用途 非线性数据结构，分层存储
    function Node(data,left,right){
        this.data=data;
        this.left=left;
        this.right=right;
        this.show=show;

    }
    function show(){
        return this.data;
    }
    function BST(){
        this.root=null;
        this.insert=insert;
        this.inOrder=inOrder;
        this.getSmallest;
        this.getMax;
        this.find;
        this.remove;
    }
    function insert(data){
        var n=new Node(data,null,null);
        if(this.root==null){
            this.root=n;
        }else{
            var current=this.root;
            while(true){
                if(n.data<current.data){
                    if(current.left!=null){
                        current=current.left;
                    }else{
                        current.left=n;
                        break;
                    }
                }else{
                    if(current.right!=null){
                        current=current.right;
                    }else{
                        current.right=n;
                        break;
                    }
                }
            }
        }
    }
    function inOrder(node){
        inOrder(node.left)
        console.log(node.data);
        inOrder(node.right)
    }
    function getSmallest(root){
        var current=root;
        while(current.left!=null){
            current=current.left;
        }
        return current.data;
    }
    function getMax(root){
        var current=root;
        while(current.right!=null){
            current=current.right;
        }
        return current.data;
    }
    function find(data){
        var current=this.root;
        while(current.data!=data){
            if(data<current.data&&current.left!=null){
                current=current.left;
            }else if(data>current.right&&current.right!=null){
                current=current.right;
            }else if(data=current.data){
                return current;
            }else{
                return false;
            }
        }
    }
    function remove(data){
        removeNode(this.root,data);
    }
    function removeNode(node,data){
        if(node==null){
            return null;
        }
        if(data==node.data){
            if(node.left==null&&node.right==null){
                return null;
            }
            if(node.left==null){
                return node.right
            }
            if(node.right==null){
                return node.left;
            }
            var tempNode=getSmallest(node.right);
            node.data=tempNode.data;
            node.right=removeNode(node.right,tempNode.data);
            return node;
        }else if(data<node.data){
                node.left=removeNode(node.left,data);
                return node;
        }else{
            node.left=removeNode(node.left,data);
            return node;
        }
    }
    // var  BST=new BST();
    // BST.insert(3);  
    // BST.insert(4);
    // BST.insert(5);
    // BST.inOrder(BST.root);  
</script>
</html>