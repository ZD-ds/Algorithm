<!--
 * @Author: your name
 * @Date: 2020-02-19 21:51:17
 * @LastEditTime: 2020-02-20 23:39:25
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edith
 * @FilePath: \Algorithm\二叉搜索树\二叉搜索树迭代器.html
 -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>

</body>
<script>
    /**
    链接https://leetcode-cn.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/64/introduction-to-a-bst/172/
    实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。

调用 next() 将返回二叉搜索树中的下一个最小的数。

 

示例：



BSTIterator iterator = new BSTIterator(root);
iterator.next();    // 返回 3
iterator.next();    // 返回 7
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 9
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 15
iterator.hasNext(); // 返回 true
iterator.next();    // 返回 20
iterator.hasNext(); // 返回 false
 

提示：

next() 和 hasNext() 操作的时间复杂度是 O(1)，并使用 O(h) 内存，其中 h 是树的高度。
你可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 中至少存在一个下一个最小的数。
*/
    /**
     * Definition for a binary tree node.
     * function TreeNode(val) {
     *     this.val = val;
     *     this.left = this.right = null;
     * }
     */
    /**
     * @param {TreeNode} root
     */
    var BSTIterator = function (root) {
        var result = [];
        var st = [];
        var p = root;
        while (p || st.length != 0) {
            while (p) //将二叉树左结点全部入栈
            {
                st.push(p);
                p = p.left;
            }
            p = st[st.length - 1]; //取出栈顶结点，即二叉树最左结点
            st.pop();
            result.push(p.val);
            p = p.right; //同样方式遍历结点右树
        }
        this.res = result;
        this.index = 0;
    };

    /**
     * @return the next smallest number
     * @return {number}
     */
    BSTIterator.prototype.next = function () {
        if (this.index < this.res.length) {
            return this.res[this.index++];
        }
    };

    /**
     * @return whether we have a next smallest number
     * @return {boolean}
     */
    BSTIterator.prototype.hasNext = function () {
        return this.index < this.res.length;
    };

    /** 
     * Your BSTIterator object will be instantiated and called as such:
     * var obj = new BSTIterator(root)
     * var param_1 = obj.next()
     * var param_2 = obj.hasNext()
     */
</script>

</html>